---
title: 位运算
date: '2022/11/12 07:37:19'
top_img: 'https://pic.hycbook.com/i//hexo/post_imgs/蕾姆1.webp'
cover: 'https://pic.hycbook.com/i//hexo/post_cover/蕾姆1.webp'
categories:
  - algorithm
tags:
  - 位运算
  - acm
description: 位运算
mathjax: true
---

---



# 位运算

## 基础

位运算基础可以见[python基础知识](https://hycbook.com/article/8258.html)

计算位运算计算时间为O(1)

> 位运算小技巧

1. 用异或实现配偶

   ```python
   0, 1
   2, 3
   4, 5
   6, 7
   
   0 ^ 1 = 1, 1 ^ 1 = 0
   2 ^ 1 = 3, 3 ^ 1 = 2
   ...
   4 ^ 1 = 5, 5 ^ 1 = 4
   ...
   ```

   

2. lowbit运算: 求1最低的位数

   ```python
   lowbit = lambda n: (-n) & n
   或
   lowbit = lambda n: (~n+1 ) & n
   
   lowbit(11110010000) = 10000
   ```

   

3. 判断奇偶

   只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数

4. 取一个数中指定位

   取X的低4位，用 X & 0000 1111 = 00001110 即可得到

5. 对一个数的某些位置1

   找到一个数，对应X要置1的位，该数的对应位为1，其余位为零。此数与X相或可使X中的某些位置1

6. 使特定位翻转

   **使特定位翻转**，该数对应X**要翻转的对应位为1**，**其余位为零**，此数与X对应位异或即可

   例：X=1010**1110**，使X低4位翻转，用X ^0000 **1111** = 1010 **0001**即可得到

7. 异或的几条性质：**异或其实就是不进位加法**

   1、**交换律** **a ^ b = c** ===> **a ^ c = b** , **b ^ c = a**

   2、**结合律** 即 **(a ^ b) ^ c == a ^ (b ^ c)**

   3、**对于任何数x，都有x ^ x = 0，x ^ 0 = x**

   4、**自反性: a ^ b ^ b = a ^ 0 = a**

8. 1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空间

   将所有的数全部异或，得到的结果与1 ^ 2 ^ 3 ^ … ^ 1000的结果进行异或，得到的结果就是重复数

9. 枚举一个无重复字符串所有子集的技巧

   用二进制数组表示单词中那些字母出现（1表示），那些没出现（0表示），找出该单词的所有子集。
   ace 对应二进制 int origin = 21 (二进制10101)，包含的子集(n代表子集,初始 n = origin)有：

   ```python
   ace 10101
   ce 10100
   ae 10001
   ac 00101
   e 10000
   c 00100
   a 00001
   遍历核心代码：n = (n - 1) & origin;// n-1 AND puzzleBit，生成一个puzzleBit的新的子集合
   可以自己手动推算一下，是对的，n刚好遍历完所有情况
   ```

   找map中 存在的 字符串str = ace（必含有首字母a）子集的个数

   ```java
    int first = 1 << (str[0] - 'a');
    while (n > 0) { // 遍历origin 的所有字母组合，当n=0时终止遍历
               // 按位都是1才为1，否则为0，即n这个组合包含origin 的首字母
               // 而且n这个组合在map中有值，即有单词长n这样，值累加给res[i]
               if ((n & first) != 0 && map[n] > 0) {
                   res[i] += map[n];
               }
               // n-1 AND puzzleBit，生成一个puzzleBit的新的子集合
               n = (n - 1) & puzzleBit;
           }
   ```

   

10. 常用位运算公式

    a >> b & 1 代表检查 a 的第 b 位是否为 1，有两种可能性 0 或者 1

    a += 1 << b 代表将 a 的第 b 位设置为 1 (当第 b 位为 0 的时候适用)

11. 



# 案例

## a^b

### 题目

> 描述

求a的b次方对p取模的值

> 难度

简单

> 输入格式

三个整数a,b,p，在同一行用空格隔开

> 输出格式

输出一个整数，表示$(a^b) \% p$的结果

> 数据范围

$$
1 \leq a,b,q \leq 10^9
$$

> 输入样例

```python
3 2 7
123456789 0 1
```

> 输出样例

```python
2
0
```

### 思路

> 快速幂

```python
3 ^ 10000000

# 先计算出
3 ^ 1 = 3
3 ^ 2 = 9
3 ^ 4 = 81
3 ^ 8 = 
3 ^ 16 = 
3 ^ 32 = 
...
3 ^ (2^19) = xxx
```

🥕核心: 再看下10000000的二进制表示，把对应为1的位乘起来就可以

10000000的二进制表示为`0b100110001001011010000000`，因此只要对应位置的值乘起来就是3 ^ 10000000

### 求解

```python
def solution(a: int, b: int, p: int) -> int:
    res = 1 % p
    while b:
        # 如果b的个位是1
        if b & 1:
            res = res * 1ll * a % p
        # 准备十位
        a = a * 1ll * a % p
        # 去掉各位
        b >>= 1

    return res
```



## a*b%p

### 题目

> 描述

求a乘b次方对p取模的值

> 难度

简单

> 输入格式

三个整数a,b,p，在同一行用空格隔开

> 输出格式

输出一个整数，表示$(a*b) \% p$的结果

> 数据范围

$$
1 \leq a,b,q \leq 10^18
$$

> 输入样例

```python
3 4 5
111 999 1000000
```

> 输出样例

```python
2
110889
```

### 思路

```python
a * b

a * 1 = a
a * 2 = 2a
a * 4 = 4a
a * 8 = 8a
...
a * (2^k) = (2^k) * a
```

### 求解

```python
def solution(a: int, b: int, p: int) -> int:
    res = 0
    while b:
        if b & 1:
            res = (res + a) % p
        a = a * 2 % p
        b >>= 1

    return res
```

